1. Napisz program w którym dla wczytanej przez użytkownika liczby wypiszę ilość wystąpień multiplikatywnych, czyli liczbę razy, przez którą należy pomnożyć poszczególne
cyfry zmiennej typu int, aż do otrzymania pojedynczej cyfry.

Przykładowo: count_multiplicate(39) ➞ 3, ponieważ 3 * 9 = 27, 2 * 7 = 14, 1 * 4 = 4 -> 4 jest pojedynczą cyfrą i program do uzyskania wyniku potrzebował trzech mnożeń.
count_multiplicate(999) ➞ 4, ponieważ 9 * 9 * 9 = 729, 7 * 2 * 9 = 126, 1 * 2 * 6 = 12, 1 * 2 = 2 -> 2 jest pojedynczą cyfrą, wynikiem jest 4.

Aby liczbę ze zmiennej integer podzielić na zmienne typu całkowitego przechowujące poszczególne cyfry, należy zastosować operacje modulo ("%") oraz wykorzystać dzielenia
do rzędów jedności, dziesiątek, setek, tysięcy itp.

Przykładowo dla liczby 39, aby "wydobyć" ostatnią cyfrę należy zastosować operację 39%10 = 9. Kolejne cyfry wymagają dodatkowo zastosowania dzielenia.

W programie należy w kolejnych liniach wyświetlać wynik mnożenia oraz wartości zmiennych przechowujących nowe cyfry.

************************************************************************************************************************************

2. Sekwencja "ślepego zaułka":
Funkcja przyjmuje dodatnią liczbę całkowitą podaną przez użytkownika (n). Zmienna s jest sumą poszczególnych cyfr w liczbie n. Jeżeli n jest podzielne przez s to kolejną
badaną liczbą jest wynik działania n/s, w przeciwnym wypadku wynikiem jest n*s. W pewnym momencie sekwencji wynikami będa dwie naprzemienne wartości zmiennych określane
jako "ślepy zaułek". Przykładowo dla danej wejściowej n równej 58 otrzymamy następujący wynik:

58 -> 754 -> 12064 -> 928 -> 17632 -> 928 -> 17632 -> 928 -> ...

Napisz program który dla podanej wartości zmiennej n wyświetli ilość działań wykonanych do momentu uzyskania "ślepego zaułka" - dwóch zmiennych powtarzających się
w wynikach obliczeń oraz ostatniej wartości zmiennej n która nie powtarza się w sekwencji. Dla powyższego przykładu (wartość zmiennej 58) wynikiem działania funkcji jest:

deadEnd(5) ➞ [5, 17632]

************************************************************************************************************************************

3. Szczęśliwe liczby:
Dla podanej dodatniej liczby całkowitej możemy utworzyć nowe liczby na podstawie wzoru który sumuje kwadraty poszczególnych cyfr w liczbie. Przykładowo dla n=203 otrzymaną
nową liczbą będzie 13, ponieważ 4 + 0 + 9 = 13. Jeżeli będziemy powtarzać obliczenia to otrzymamy następującą sekwencję liczb:

203 -> 13 -> 10 -> 1 -> 1

Czasami, jak w przykładzie powyższym otrzymamy sekwencję liczb w której ostatnią wartością będzie liczba 1. Takie liczby nazywane są liczbami szczęśliwymi (Happy Numbers).
Nie wszytkie liczby są liczbami szczęśliwymi. Przykładowo dla n=11 otrzymamy następującą sekwencję:

11 -> 2 -> 4 -> 16 -> ...

Powyższa sekwencja nigdy nie zakończy się na wyniku 1, wobec tego liczba taka nazywana jest nieszczęśliwą (Unhappy Number)

Napisz program, który dla podanej przez użytkownika dodatniej liczby całkowitej wyświetli informację, czy liczba jest szczęśliwa czy nieszczęśliwa. Dla obu przypadków
wyświetl sekwencje z obliczeniami (dla liczby nieszczęśliwej ogranicz wyświetlanie wyników do 20 liczb).

Przykładowo:
is_happy(203) ➞ true ➞ "Liczba 203 jest szczęśliwa, ponieważ x -> y -> z -> ... "

is_happy(11) ➞ false ➞ "Liczba 11 jest nieszczęśliwa, ponieważ x -> y -> z -> ... "

is_happy(107) ➞ false ➞ "Liczba 107 jest nieszczęśliwa, ponieważ x -> y -> z -> ..."

************************************************************************************************************************************

4. Szczęśliwe liczby (wersja tablicowa):

Badany jest ciąg liczb całkowitych w tablicy o wartościach 0 lub 1:

[0, 1, 0, 0, 0, 1, 1, 1, 0, 1]

Liczba 1 w tablicy jest liczbą nieszczęśliwą, jeżeli liczby po jej lewej i prawej stronie mają wartość 0.
Liczba 0 w tablicy jest liczbą nieszczęśliwą, jeżeli liczby po jej lewej i prawej stronie mają wartość 1.
Jeżeli liczba ma tylko jednego sąsiada, ta liczba jest nieszczęśliwa, jeżeli sąsiad posiada inną wartość liczbową niż liczba badana.
    W przeciwnym wypadku badana liczba jest liczbą szczęśliwą.
    
W powyższym przykładzie:
- pierwszy element (0) oraz element ostatni (1) tablicy to liczby nieszczęśliwe
- drugi element tablicy (1) jest liczbą nieszczęśliwą
- przedostatni element tablicy (0) jest liczbą nieszczęśliwą
- pozostałe liczby w tablicy są liczbami szczęśliwymi

Napisz program która wczyta od użytkownika rozmiar tablicy liczb całkowitych. Program następnie wczytuje od użytkownika liczby do tablicy (wartości 0 lub 1, jeżeli
użytkownik poda inną liczbą, program powinien o tym poinformować i ponownie poprosić użytkownika i podanie wartości dla danego indeksu tablicy). Wynikiem działania
programu jest stosunek liczb szczęśliwych do wszystkich liczb w tablicy, wyrażony w procentach:

happy numbers = (happy 0s + happy 1s) / total numbers * 100

Wynikiem działania programu dla powyższego zbioru liczb [0, 1, 0, 0, 0, 1, 1, 1, 0, 1] jest 0.6 (60% liczb szczęśliwych), ponieważ:

0 1 0 0 0 1 1 1 0 1
N N S S	S S S S	N N

happy numbers = (3 + 3)/10 * 100 = 60 ("%")

Przykłady działania funkcji dla innych zbiorów liczb:

portionHappy([0, 1, 0, 1, 0]) ➞ 0 (0%)
portionHappy([0, 1, 1, 0]) ➞ 0.5 (50%)
portionHappy([0, 0, 0, 1, 1]) ➞ 1 (100%)
portionHappy([1, 0, 0, 1, 1]) ➞ 0.8 (80%)


************************************************************************************************************************************

5. Punkty podparcia - wersja tablicowa

Punktem podparcia w tablicy liczb całkowitych jest taka liczba, że wszystkie elementy na lewej od niej i wszystkie elementy na prawo od niej sumują się do tej 
samej wartości.

Przykładowo:

findFulcrum([3, 1, 5, 2, 4, 6, -1]) ➞ 2 , ponieważ [3,1,5] (elementy po lewej stronie od badanej liczby) i [4,6,-1] (elementy po prawej stronie od badanej liczby)
sumują się do 9.

Napisz funkcję która sprawdzi tablicę pod kątem wystąpienia punktu podparcia (jeżeli taki punkt w tablicy się nie znajduje, to program wyświetli stosowną informację).
Dane wejściowe podawane przez użytkownika to wielkość tablicy oraz liczby całkowite.

Przykłady to testowania poprawności programu:

findFulcrum([1, 2, 4, 9, 10, -10, -9, 3]) ➞ 4
findFulcrum([9, 1, 9]) ➞ 1
findFulcrum([7, -1, 0, -1, 1, 1, 2, 3]) ➞ 0
findFulcrum([8, 8, 8, 8]) ➞ -1

************************************************************************************************************************************

6. Parowanie skarpetek

Dysponujesz tablicą liczb całkowitych. Liczby te reprezentują różne kolory skarpetek. Napisz program, a w nim odpowiednią funkcję, która na podstawie wielkości tablicy
oraz liczb całkowitych (reprezentujących kolory skarpetek) wprowadzonych przez użytkownika wyświetli na ekranie ilość sparowanych skarpetek. 

Przykładowo:

sockMerchant[1, 2, 1, 2, 1, 3, 2] ➞ 2 , ponieważ z 7 dostępnych kolorów skarpetek uda się wydobyć 2 pary o takim samym kolorze - są to pary o numerze 1 oraz 2.

Trzy skarpetki zostają bez pary:

[1,  2,  1,  2,  1,  3,  2]
P1   P2  P1  P2  X   X   X

Przykłady do testowania poprawności programu:
sockMerchant([10, 20, 20, 10, 10, 30, 50, 10, 20]) ➞ 3
sockMerchant([50, 20, 30, 90, 30, 20, 50, 20, 90]) ➞ 4
sockMerchant([]) ➞ 0

************************************************************************************************************************************

7. Powtarzający się cykl

Poniżej widoczny jest przykład tablicy wypełnionej liczbami całkowitymi, w której występuje powtarzający się cykl:

isRepeatingCycle([1, 2, 3, 1, 2], 3) => true , ponieważ pierwsze dwa elementy z podzbioru [1,2,3] występują na 4 i 5 pozycji w tablicy

Poniżej widoczny jest przykład tablicy wypełnionej liczbami całkowitymi, w której NIE występuje powtarzający się cykl:

isRepeatingCycle([1, 2, 3, 1, 3], 3) => false , ponieważ [1,2,3] != [1,3]

Napisz funkcję która przyjmuje dwa argumenty:
1. Tablicę liczb całkowitych
2. Długość cyklu który będzie sprawdzany

Funkcja zwraca wartość logiczną "true", jeżeli w tablicy występuje powtarzjacy się cykl, lub "false", jeżeli cykl ten nie występuje.

WSZYSTKIE elementy sprawdzane w tablicy muszą być zgodne z wzorcem (długością cyklu). Przykładowo:
isRepeatingCycle([1, 2, 3, 1, 2], 3) => true , ponieważ sprawdzanie elementów tablicy kończy się na drugiej pozycji wzorca ( [1,2,3] <=> [1,2] )
isRepeatingCycle([1, 2, 3, 1, 2, 1], 3) => false , ponieważ ostatni element tablicy łamie szyk ( [1,2,3] != [1,2,1] )

Przykłady do testowania poprawności programu:

isRepeatingCycle([1, 2, 3, 1, 2, 3, 1], 3) ➞ true
isRepeatingCycle([1, 2, 3, 4, 2, 3, 1], 4) ➞ false
isRepeatingCycle([1, 2, 1, 2, 2], 2) ➞ false
isRepeatingCycle([1, 1, 1, 1], 3) ➞ true

************************************************************************************************************************************

8. Napisz program który będzie symulował grę w Blackjacka (oczko) dla dwóch osób. Gra polega na "losowaniu" (generowaniu liczb pseudolosowych) karty z talii kart,
oraz dodaniu do wyniku gracza wartości tej karty. Zasadniem gracza jest uzyskanie jak najbliżej (ale nie więcej niż) 21 punktów. Zasady punktowania kart:
- karty od 2 do 9 oczek - mają tyle samo punktów, co oczek
- "10", Walet, Dama, Król - mają po 10 punktów
- As - ma 1 lub 11 punktów. Po wylosowaniu asa gracz sam decyduje czy jest on punktowany za 1 czy za 11.

Wytyczne do programu:
- Gra Blackjack jest grą dla dwóch osób - wygrywa ta osoba która uzyska wynik bliższy 21 punktów.
- Program na podstawie "rzutu monetą" (liczby pseudolosowej) decyduje o tym który gracz zaczyna grę.
- Losowanie odbywa się naprzemiennie, np. gracz 1 losuje kartę -> program pyta gracza 1 czy zachować wynik -> gracz 2 losuje kartę -> ...
- Gdy program wylosuje kartę "As" - pyta użytkownika czy do wyniku dodać 1 lub 11 punktów.
- Gry gracz przekroczy 21 punktów - wygrywa przeciwnik.
- Gdy gracze mają poniżej 21 punktów - wygrywa ta osoba, która uzyskała wynik bliższy 21.

************************************************************************************************************************************

9. Napisz program który będzie symulował grę w "Wisielca" (ang. Hangman) dla dwóch osób. Gra polega na podaniu hasła przez gracza i odgadnięciu tego hasła przez
gracza drugiego przy jednoczesnym podawaniu spółgłosek i samogłosek. Gra zmodyfikowana w następujący sposób:
- Pseudolosowość programu decyduje o tym, czy gracz pierwszy lub drugi zaczyna grę (podaje hasło)
- Program po wczytaniu hasła przez gracza rozpoczynającego wymazuje zawartość na ekranie (system("CLS"))
- Program wyświetla dla gracza drugiego hasło w zaszyfrowanej postaci, np. "------_----_-----", gdzie "-" oznacza litery nieodgadnięte, "_" oznacza odstęp między wyrazami
- 



